<! -- David Grethlein, djg329@drexel.edu -->
<! -- Rubix Cube Index Template -->

{% extends 'base.html' %}
{% set active = "Home" %}

{% block title %}
Home
{% endblock %}

{% block content %}

<section class="jumbotron">
    <div class="text-center">
        <h1 class="jumbotron-heading">Rubix Cube</h1>
    </div>
    <script src="js/three.js"></script>
    <script>
// three.js shape to line

var renderer, scene, camera;

var line;
var MAX_POINTS = 500;
var drawCount;
var value = 1;
var delta = -0.01;
var cube_arr = [];

var last = false;
var quaternion = new THREE.Quaternion;
var axis = new THREE.Vector3(1,0,0);

init();
animate();

function init() {

      // info
      var info = document.createElement('div');
      info.style.position = 'absolute';
      info.style.top = '30px';
      info.style.width = '100%';
      info.style.textAlign = 'center';
      info.style.color = '#fff';
      info.style.fontWeight = 'bold';
      info.style.backgroundColor = 'transparent';
      info.style.zIndex = '1';
      info.style.fontFamily = 'Monospace';

      document.body.appendChild(info);

      // renderer
      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // scene
      scene = new THREE.Scene();

      // camera
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
      camera.position.set(50, 50, 500);

      renderer.domElement.addEventListener( 'mousedown', event => {

        last = new THREE.Vector2( event.clientX, event.clientY );

      });

      renderer.domElement.addEventListener( 'mousemove', event => {

        if( last ){

          let delta = event.clientX - last.x;

          camera.position.applyQuaternion( quaternion.setFromAxisAngle(
            axis, Math.PI * 2 * (delta / innerWidth)
          ));
          camera.lookAt( scene.position );

          last.set( event.clientX, event.clientY );

        }

        renderer.render( scene, camera );

      });

      renderer.domElement.addEventListener( 'mouseup', event => {

        last = false;

      });


      // material
      var material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        vertexColors: THREE.FaceColors
      });

      // geometry
      geometry = new THREE.BoxGeometry(40, 40, 40);

      // colors
      red = new THREE.Color(1, 0, 0);
      green = new THREE.Color(0, 1, 0);
      blue = new THREE.Color(0, 0, 1);
      var colors = [red, green, blue];

      for (var row_idx = 0; row_idx < 3; row_idx++) {
          for (var col_idx = 0; col_idx < 3; col_idx++) {
              for (var dep_idx = 0; dep_idx < 3; dep_idx++) {

                  for (var i = 0; i < 3; i++) {
                      geometry.faces[4 * i].color = colors[i];
                      geometry.faces[4 * i + 1].color = colors[i];
                      geometry.faces[4 * i + 2].color = colors[i];
                      geometry.faces[4 * i + 3].color = colors[i];
                  }

                  // mesh
                  var box = new THREE.Mesh(geometry, material);
                  cube_arr.push(box)
                  box.position.set(row_idx * 50, col_idx * 50, dep_idx * 50)
                  scene.add(box);
                  console.log(cube_arr[-1]);
              }
          }
      }
    }

    scene.add(new THREE.AxesHelper)

    // render
    function render() {
      renderer.render(scene, camera);
    }

    function animateBox() {
      angle = 0.02;
      for (var cube_idx = 0; cube_idx < cube_arr.length; cube_idx++) {

        var cube = cube_arr[cube_idx];

        //console.log(cube_arr[cube_idx]);
        cube.rotateX(-1.0*angle);
        cube.rotateY(4.0*angle);
        cube.rotateZ(-3.0*angle);
      }
    }

    function changeFaceColors() {
      if (value <= 0) {
        delta = 0.01;
      }
      else if(value >= 1) {
        delta = -0.01;
      }
      red.r = green.g = blue.b = value += delta;
      geometry.colorsNeedUpdate = true;
    }

    // animate
    function animate() {
      //animateBox();
      //changeFaceColors();
      requestAnimationFrame(animate);
      render();
    }

    </script>
</section>

{% endblock %}

